<Process vs Thread>
Process: 운영체제로부터 자원을 할당받는 작업의 단위
Thread: 할당받은 자원을 이용하는 실행의 단위(Process내에 여러 개 생길 수 있음)
*어플리케이션 하나가 Process이고, 그 안에서의 분기 처리가 Thread임

<Multi-Process vs Multi-Thread>
Multi-Process: 하나의 Program을 여러 개의 Process로 구성하여 각 Process가 하나의 작업(task)을 처리하는 것
  장점-하나의 Process가 잘못 되어도 Program은 동작함
  단점-context switching 비용 발생
  *context switching: CPU에서 여러 Process를 돌아가면서 작업을 처리하는데 이 과정을 일컫는 말.
                      동작 중인 Process가 대기를 하면서 해당 Process의 상태(context)를 보관하고 대기하고 있다가 다시 실행시 복구하는 비용(시간)을 일컬음
Multi-Thread: Program을 여러 개의 Thread로 구성하고 각 Thread가 작업(task)를 처리하는 것
  장점-시스템 자원 소모 감소, 처리 비용 감소(실행 속도 향상), Thread간 자원 공유(Stack영역)
  단점-debugging 어려움, 동기화 이슈 발생, 하나의 Thread의 오류로 전체 Process에 문제 발생

Thread Safe: 여러 thread가 동시에 사용되어도 안전하다는 것을 뜻함
             특정함수 A와 변수 AA가 여러 thread에서 호출되어도 하나의 thread에서 호출했을 때와 같은 결과가 보장되어야 한다는 의미
             (함수가 전역 변수를 참조하게 되면 그 함수는 Thread Safe하지 않은 결과가 나올 수 있다)
             
비동기 프로그래밍:
  1) 비동기 프로그래밍의 개념

비동기연산은 크기가 큰 파일을 읽거나 원격 컴퓨터에 접속하는 등 시간이 오래 걸리는 작업을 수행할 때 흔히 사용하는 방법이다. 먼저 메인 애플리케이션 스레드가 아닌 다른 스레드 혹은 OS에 의해 수행되기도 하기 때문에 비동기 연산을 요청한 후 결과가 나오기를 기다리는 대신 다른 작업을 할 수 있다.

 

2) 동기 프로그래밍, 비동기 프로그래밍

일반적으로 프로그래밍에서 시간이 오래 걸리는 작업은 두 가지로 볼 수 있다.

  a. 파일 입출력, 소켓 프로그래밍 등 I/O가 수반된 프로그램은 데이터를 요청한 후 결과를 받기까지 시간이 오래 걸린다. 하드 디스크를 읽고 쓰는 일이나 네트워크를 통해 데이터를 주고 받는 것이 CPU가 데이터를 처리하는 속도에 비해 현저히 느리기 때문이다.

  b. I/O없이 CPU만 사용할 때도 암호화 연산처럼 복잡한 계산이 필요한 경우 오랜 시간이 걸린다.(알고리즘에 복잡도에 의한 성능문제) 

 

개발자가 컴퓨터의 응답을 기다리는 방식은 동기 프로그래밍과 비동기 프로그래밍 두 가지가 있다.

먼저 동기 프로그래밍은 시간이 얼마나 걸리든 요청에 대한 응답이 올 때까지 프로그램 수행을 멈추고 기다리는 방식이다. 프로그램 흐름이 순차적으로 흐르기 때문에 이해가 쉽고 작성하기 쉽다.

두번째로 비동기 프로그래밍은 연산을 요청한 후에 결과를 기다리지 않고 다른 작업을 수행하는 프로그래밍 스타일을 말한다.

 

3) 비동기 프로그래밍을 하기 위해 기본적으로 알아야 할 개념들 ...

  a. 비동기 I/O

   I/O가 빈번한 애플리케이션은 대부분의 시간을 요청한 I/O가 수행되기를 기다리면서 소비하게 된다. 이렇게 소비되는 시간을 막고자 일단 I/O를 요청한 후에 결과를 보지 않고 다른 연산을 하다가 나중에 앞서 요청한 I/O의 결과를 확인하는 방식을 채택한 것이 비동기 I/O이다.

  b. 폴링(Polling)

   비동기 I/O의 가장 기본적인 형태는 폴링이다. 폴링은 일단 I/O를 요청한 후에 애플리케이션을 알아서 일정한 시간이 지난 후에 I/O가 끝났는지 물어보는 방식이다. 폴링에서는 종료 여부를 얼마나 자주 확인하느냐가 중요한 변수가 된다. 만약 I/O를 요청한 후에 요청한 I/O가 끝날 때까지 할 일이 없어서 계속해서 폴링을 한다면 동기 방식에 비해 귀중한 CPU자원만 낭비하는 셈이 된다. 폴링을 위해 자주 CPU를 사용하면 다른 프로세스가 연산을 수행할 시간을 빼앗게 된다.

  c. Select/Poll

   BSD 유닉스 계열에서 출발한 Select 시스템 콜은 폴링의 단점을 극복하기 위한 방법이다. Select는 한 번에 여러 개의 파일 디스크립터를 감시하는 역할을 한다. 여러개의 디스크립터를 감시하다가 폴링과 I/O가 가능해지면 깨어나서 처리하는 방식이다. 이때 폴링과 달리 Select는 기다리는 동안 CPU자원을 낭비히지 않으면서 기다린다.(Sleep)

  d. 시그널 혹은 콜백함수

   시그널이나 콜백함수가 하는 역할은 BSD나 Posix 유닉스 계열에서는 I/O를 비동기로 요청하고 I/O가 끝나면 시그널을 발생시켜서 I/O의 종료 사실을 알려준다. Mac OS나 윈도우에서는 이보다 조금 더 세련된 방식의 콜백함수를 사용한다. 근본적으로는 시그널과 큰 차이가 없지만 시그널이 각 시그널마다 하나의 시그널 핸들러 밖에 등록할 수 없는데 비해서, 콜백 방식은 I/O요청마다 별도의 완료 호출함수를 지정할 수 있기 때문에 프로그래밍 하기가 훨씬 편하다.

  e. 멀티 스레드

    동기 I/O를 사용하더라도 비동기 I/O의 효과를 낼 수 있는 방법으로써 멀티스레드가 있다. 멀티스레드란 애플리케이션의 진행을 방해하지 않기 위해서 시간이 오래 걸리는 작업은 별도의 스레드로 실행시키는 방법이다. 실제 I/O는 블로킹이지만 I/O가 다른 스레드에서 실행되기 때문에 I/O를 수행하는 와중에 다른 작업을 할 수 있다.

 

========================================================================================================================

비동기 소켓이란.

동  기 : 소켓이 서로 통신할 때 데이터를 언제 보낼 것인가와 언제 받을 것인가를
      알고 있는 경우의 통신. 만약 데이터를 보냈는데 받지 못하는 상황이 발생
하거나 데이터를 받을 준비를 했는데 아무것도 오지 않는 상황이 발생한다면
이로 인해 프로그램이 멈추게 된다. 언제 데이터가 오고 가는지 알고 있어야만
통신이 가능해진다.
비동기  : 서로 통신할 시기를 알지 못하는 경우를 생각해보면 언제 올지 모르는 데이터를
        계속 기다리는 것은 비효율적인 작동방식이 된다. 이를 효율적으로 작동시키기 위
        해서는 언제 데이터가 오는지는 알 필요 없이 데이터가 왔는지 안 왔는지만 확인해
        서 다른 작업을 하다가 데이터가 왔다면 그 때 도착한 데이터를 받아 들인 후 처리
        하면 된다.

블러킹모드와 넌블러킹모드

블러킹모드 : 소켓은 기본적으로 socket()함수를 써서 소켓을 생성하게 되면 블러킹모드로
            만들어지게 된다. 블러킹모드에서 send()나 recv()함수를 호출하게 되면 데이
            터가 가거나 오지 않는 이상 이 함수는 리턴을 하지 않고 계속 머무르게 되어
            있다.
넌블러킹모드: fcntl()함수를 이용하여 소켓을 넌블러킹모드로 만들 수 있다. 이렇게 해서 만
            들 경우 소켓은 데이터를 보내거나 받을 시 데이터가 있으면 바로 보내거나
            받게 되고 없다면 errno변수(errno.h 헤더에 있다)에 상태를 기록하게 된다.
            이 상태변수를 보고 무엇을 할지 결정하면 된다.

함수의 블록상태와 넌블럭상태
함수를 호출했을 때 리턴이 되지 않고 어떠한 상태가 될 때까지 무한히 기다리게 되는 경우가 있게되면 이것은 블록킹함수이고 이러한 상태가 없이 어떤 결과든 리턴해주게되는 경우가 넌블럭킹함수이다.



비동기의 방식

블록과 넌블록함수는 프로그램의 상태를 말해주는 의미이고 동기와 비동기는 읽기와 쓰기의 상태에 때라 구별되는 개념이다. 동기란 입력과 출력의 상호간에 약속에 의해 동시간에 이루어지는 것이다. 즉 A라는 상대가 1시에 파일을 보내기로 했다면 이것을 받는 B라는 상대도 1시에 정확히 파일을 받는 것을 의미한다. 만약 B가 1시 이전부터 파일을 받으려고 한다면 1시까지는 기다려야 함을 의미하며 B가 1시에 기다리고 있는데 A가 보내지 않는 다면 B는 A가 보낼 때까지 기다려야 함을 의미한다. 비동기는 언제 보내고 언제 받을지를 결정하지 않고 상대가 보낸다는 신호를 받으면 그 때 받는 행동을 하는 것이다. 비동기의 예를 들면 전화나 편지가 있다. 상대가 언제 보낼지 알 수 없고 전화벨이 울리면 그 때 받으면 된다. 전화벨이 울리기 전까지는 다른 일을 해도 된다.

비동기의 방식에는 여러가지가 있는데 윈도우와 유닉스의 방식에는 같이 쓸 수 있는 방법이
select()함수를 이용한 방법이 있다. 그리고 윈도우에서 지원해주는 여러가지 함수를 이용해서 다양한 방법을 쓸 수 있다. 리눅스에서는 select()나 poll()함수를 이용하여 만들 수 있는데 이 방법은 엄밀히 말하면 비동기가 아니다. 단지 운영체제가 언제 recv나 send함수를 호출해야 하는 지를 가르쳐주기 때문에 통신은 동기로 이루어 지지만 방식은 비동기에 가깝다. 진정한 비동기 방식은 운영체제에서 프로그램에 인터럽트를 걸고 데이터가 왔다고 알린 후 콜백함수를 등록하여 이를 호출하여 처리되는 식으로 동작할 것이다. 하지만 이런 방식은 구현이 까다롭고 OS에 대해 잘 알고 있어야 하며 select나 poll 방식에 비해 효율적이라고 할 수도 없어서 대부분 다른 방식을 사용한다고 한다.
이런 방식으로 SIGNAL 방식이 있다. 이것은 운영체제에 어떠한 신호를 등록해두고 자신은 다른 일을 하다가 신호가 오면 운영체제가 신호를 받아서 미리 등록해둔 방식으로 동작하도록 하는 것이다. 이 방식은 쓰레드를 써야하며 멀티플렉싱이 이루어 져야 할 때는 모든 소켓을 뒤져야 하므로 poll이나 select 방식에 비해 장점이 없다. 이러한 단점을 극복한 방법으로 REALTIME SIGNAL이라는 방법이 있지만 구현이 까다롭다고 한다.
